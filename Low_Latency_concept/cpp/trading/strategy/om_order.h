#pragma once

#include <array>
#include <sstream>
#include "common/types.h"

using namespace Common;

/*
 * OM ORDER - ORDER MANAGER ORDER STATE
 * =====================================
 * 
 * PURPOSE:
 * Defines internal order representation for the Order Manager.
 * Tracks order state through lifecycle (NEW, LIVE, CANCEL, DEAD).
 * 
 * DIFFERENCE FROM EXCHANGE ORDERS:
 * - Exchange: MEClientRequest/Response (wire protocol)
 * - Order Manager: OMOrder (internal state tracking)
 * 
 * ORDER LIFECYCLE (State Machine):
 * ```
 * INVALID
 *   |
 *   v (newOrder)
 * PENDING_NEW -----> [Exchange processes]
 *   |
 *   v (ACCEPTED response)
 * LIVE -----> [Order in exchange book]
 *   |
 *   v (cancelOrder)
 * PENDING_CANCEL --> [Exchange processes]
 *   |
 *   v (CANCELED response or fully FILLED)
 * DEAD
 * ```
 * 
 * STATE TRANSITIONS:
 * 
 * INVALID -> PENDING_NEW:
 * - Action: newOrder() sends NEW request
 * - Waiting: Exchange to accept
 * 
 * PENDING_NEW -> LIVE:
 * - Event: ACCEPTED response from exchange
 * - Order: Now resting in exchange order book
 * 
 * LIVE -> PENDING_CANCEL:
 * - Action: cancelOrder() sends CANCEL request
 * - Waiting: Exchange to confirm cancellation
 * 
 * LIVE -> DEAD (via FILLED):
 * - Event: FILLED response (leaves_qty = 0)
 * - Order: Fully executed, removed from book
 * 
 * PENDING_CANCEL -> DEAD:
 * - Event: CANCELED response from exchange
 * - Order: Removed from exchange order book
 * 
 * ANY -> DEAD:
 * - Reason: Fully filled, canceled, rejected
 * - Can reuse: Set back to INVALID, send new order
 * 
 * WHY PENDING STATES:
 * - Network latency: 1-10 μs (co-located)
 * - Exchange processing: 1-5 μs
 * - Total round-trip: 2-15 μs
 * - During this time: Order state is pending
 * - Important: Don't send duplicate orders
 * 
 * PERFORMANCE:
 * - Struct: Plain old data (POD), no virtual functions
 * - Size: ~40 bytes (cache-friendly)
 * - No heap allocation: Stored in arrays
 * - Fast state checks: Simple enum comparison
 */

namespace Trading {
  /*
   * OM ORDER STATE - ORDER LIFECYCLE STATES
   * ========================================
   * 
   * Enumeration representing order state in Order Manager.
   * 
   * STATES:
   * 
   * INVALID (0):
   * - Initial state (no order)
   * - Default value after order fully processed
   * - Can transition to: PENDING_NEW
   * 
   * PENDING_NEW (1):
   * - NEW request sent to exchange
   * - Waiting for ACCEPTED response
   * - Cannot: Send another NEW (duplicate order risk)
   * - Can transition to: LIVE (accepted) or DEAD (rejected)
   * 
   * LIVE (2):
   * - Order accepted by exchange
   * - Resting in exchange order book
   * - Can: Cancel, modify (via cancel+replace)
   * - Can transition to: PENDING_CANCEL, DEAD (filled)
   * 
   * PENDING_CANCEL (3):
   * - CANCEL request sent to exchange
   * - Waiting for CANCELED response
   * - Cannot: Send another CANCEL (duplicate)
   * - Can transition to: DEAD
   * 
   * DEAD (4):
   * - Order no longer active
   * - Reasons: Canceled, filled, rejected
   * - Can: Send new order (reset to INVALID first)
   * 
   * STATE MACHINE VALIDATION:
   * - Invalid transitions: Caught by switch statements
   * - Example: Cannot cancel DEAD order (no-op)
   * - Example: Cannot send NEW while PENDING_NEW
   */
  enum class OMOrderState : int8_t {
    INVALID = 0,         // No order / initial state
    PENDING_NEW = 1,     // NEW sent, waiting for ACCEPTED
    LIVE = 2,            // Order active in exchange book
    PENDING_CANCEL = 3,  // CANCEL sent, waiting for CANCELED
    DEAD = 4             // Order no longer active
  };

  /*
   * OM ORDER STATE TO STRING
   * ========================
   * 
   * Converts OMOrderState enum to string for logging.
   * 
   * Used for:
   * - Debug logging
   * - Order state display
   * - Error messages
   */
  inline auto OMOrderStateToString(OMOrderState side) -> std::string {
    switch (side) {
      case OMOrderState::PENDING_NEW:
        return "PENDING_NEW";
      case OMOrderState::LIVE:
        return "LIVE";
      case OMOrderState::PENDING_CANCEL:
        return "PENDING_CANCEL";
      case OMOrderState::DEAD:
        return "DEAD";
      case OMOrderState::INVALID:
        return "INVALID";
    }

    return "UNKNOWN";  // Should never reach (all cases covered)
  }

  /*
   * OM ORDER STRUCTURE
   * ==================
   * 
   * Internal order representation for Order Manager.
   * Stores order attributes and current state.
   * 
   * FIELDS:
   * 
   * ticker_id_:
   * - Instrument identifier
   * - Used for: Risk checks, position tracking
   * 
   * order_id_:
   * - Unique order identifier (per trading session)
   * - Generated by: Order Manager (incremental counter)
   * - Used for: Cancels, tracking responses
   * 
   * side_:
   * - BUY or SELL
   * - Determines: Position direction
   * 
   * price_:
   * - Limit price (fixed-point, 6 decimal places)
   * - Used for: Order book placement
   * 
   * qty_:
   * - Order quantity (remaining, not original)
   * - Updated on: Partial fills
   * - Zero: Order fully filled (DEAD)
   * 
   * order_state_:
   * - Current lifecycle state (see enum above)
   * - Critical: Prevents duplicate orders/cancels
   * 
   * MEMORY LAYOUT:
   * - Size: ~40 bytes (varies by platform)
   * - Alignment: Natural (uint64_t aligned)
   * - Cache-friendly: Fits in single cache line (64 bytes)
   * 
   * USAGE PATTERN:
   * ```cpp
   * // Array per ticker per side (BUY, SELL)
   * OMOrderTickerSideHashMap orders;
   * 
   * // Access BUY order for ticker 0
   * auto* bid_order = &orders[0][sideToIndex(Side::BUY)];
   * 
   * // Send new order
   * if (bid_order->order_state_ == OMOrderState::INVALID) {
   *   order_manager->newOrder(bid_order, 0, 100.50, Side::BUY, 10);
   *   // bid_order->order_state_ = PENDING_NEW
   * }
   * ```
   */
  struct OMOrder {
    TickerId ticker_id_ = TickerId_INVALID;      // Instrument ID
    OrderId order_id_ = OrderId_INVALID;          // Unique order ID
    Side side_ = Side::INVALID;                   // BUY or SELL
    Price price_ = Price_INVALID;                 // Limit price
    Qty qty_ = Qty_INVALID;                       // Remaining quantity
    OMOrderState order_state_ = OMOrderState::INVALID;  // Current state

    /*
     * TO STRING - FORMAT ORDER FOR LOGGING
     * =====================================
     * 
     * Formats OMOrder for human-readable logging.
     * 
     * Example output:
     * "OMOrder[tid:0 oid:12345 side:BUY price:100.50 qty:10 state:LIVE]"
     * 
     * Used for:
     * - Debug logging
     * - Order state tracking
     * - Error investigation
     */
    auto toString() const {
      std::stringstream ss;
      ss << "OMOrder" << "["
         << "tid:" << tickerIdToString(ticker_id_) << " "
         << "oid:" << orderIdToString(order_id_) << " "
         << "side:" << sideToString(side_) << " "
         << "price:" << priceToString(price_) << " "
         << "qty:" << qtyToString(qty_) << " "
         << "state:" << OMOrderStateToString(order_state_) << "]";

      return ss.str();
    }
  };

  /*
   * OM ORDER HASH MAPS
   * ==================
   * 
   * Efficient storage and lookup for strategy orders.
   * 
   * OMOrderSideHashMap:
   * - Array indexed by Side (BUY=0, SELL=1)
   * - Size: 2 elements (BUY order, SELL order)
   * - Usage: Store buy and sell orders for one ticker
   * - O(1) access by side
   * 
   * OMOrderTickerSideHashMap:
   * - Array indexed by TickerId
   * - Each element: OMOrderSideHashMap (BUY, SELL)
   * - Size: ME_MAX_TICKERS tickers * 2 sides
   * - Usage: Store all strategy orders (all tickers, all sides)
   * - O(1) access by ticker and side
   * 
   * MEMORY:
   * - Total size: ~40 bytes/order * 2 sides * N tickers
   * - Example: 10 tickers = 800 bytes (very small)
   * - Stack allocation: Fast, cache-friendly
   * 
   * TYPICAL USAGE:
   * ```cpp
   * // Declare storage (typically in OrderManager)
   * OMOrderTickerSideHashMap ticker_side_order_;
   * 
   * // Access specific order (ticker 0, BUY side)
   * auto* order = &ticker_side_order_[0][sideToIndex(Side::BUY)];
   * 
   * // Check state
   * if (order->order_state_ == OMOrderState::LIVE) {
   *   // Order is active, can cancel
   *   order_manager->cancelOrder(order);
   * }
   * ```
   */
  
  // Hash map from Side -> OMOrder
  // Size: 2 (BUY, SELL)
  // Access: [sideToIndex(Side::BUY)] or [sideToIndex(Side::SELL)]
  typedef std::array<OMOrder, sideToIndex(Side::MAX) + 1> OMOrderSideHashMap;

  // Hash map from TickerId -> Side -> OMOrder
  // Size: ME_MAX_TICKERS * 2
  // Access: [ticker_id][sideToIndex(side)]
  typedef std::array<OMOrderSideHashMap, ME_MAX_TICKERS> OMOrderTickerSideHashMap;
}

/*
 * OM ORDER DESIGN CONSIDERATIONS
 * ===============================
 * 
 * 1. STATE MACHINE:
 *    - Explicit states prevent bugs
 *    - Example: Cannot send duplicate NEW while PENDING_NEW
 *    - Example: Cannot cancel INVALID order
 *    - Critical: Race conditions with exchange responses
 * 
 * 2. PENDING STATES IMPORTANCE:
 *    - Network round-trip: 2-15 μs typical
 *    - During this time: Don't send duplicate actions
 *    - PENDING_NEW: Prevent duplicate order submissions
 *    - PENDING_CANCEL: Prevent duplicate cancel requests
 * 
 * 3. QUANTITY TRACKING:
 *    - qty_: Remaining quantity (leaves_qty from exchange)
 *    - Updated on: Each partial fill
 *    - Zero: Order fully filled, transition to DEAD
 *    - Original qty: Not stored (not needed for management)
 * 
 * 4. ARRAY-BASED STORAGE:
 *    - std::array: Fixed-size, stack allocation
 *    - Fast: O(1) access, no heap allocation
 *    - Cache-friendly: Contiguous memory
 *    - Simple: No pointer management
 *    - Limitation: Max tickers fixed at compile time
 * 
 * 5. ONE ORDER PER SIDE PER TICKER:
 *    - Simplification: Market maker has one BUY, one SELL
 *    - Advantage: Simple state management
 *    - Cancel-replace: Cancel old, send new (common pattern)
 *    - Not suitable for: Multi-order strategies (need different design)
 * 
 * RACE CONDITIONS:
 * 
 * Scenario 1: Cancel-Replace Race
 * - T0: Send NEW order (PENDING_NEW)
 * - T1: Order ACCEPTED (LIVE)
 * - T2: Price changes, send CANCEL (PENDING_CANCEL)
 * - T3: FILLED response arrives (before CANCELED)
 * - Handle: Check state on response, FILLED takes priority
 * 
 * Scenario 2: Multiple Price Updates
 * - T0: BBO changes to 100.50
 * - T1: Send order at 100.50 (PENDING_NEW)
 * - T2: BBO changes to 100.51 (want to update)
 * - T3: Wait! Order still PENDING_NEW
 * - Action: Wait for ACCEPTED, then cancel-replace
 * 
 * Scenario 3: Fill During Cancel
 * - T0: Order LIVE at 100.50
 * - T1: Send CANCEL (PENDING_CANCEL)
 * - T2: FILLED response (crossed by aggressive order)
 * - T3: CANCEL_REJECTED (order already filled)
 * - Handle: FILLED transitions to DEAD, ignore CANCEL_REJECTED
 * 
 * PRODUCTION ENHANCEMENTS:
 * - Timestamps: Track when each state transition occurred
 * - Original quantity: Store original qty for analytics
 * - Fill tracking: Array of fills (for VWAP, reporting)
 * - Execution venue: Which exchange/venue
 * - Client order ID: Separate from exchange order ID
 * - Order type: LIMIT, MARKET, IOC, FOK (currently only LIMIT)
 * - Time in force: DAY, GTC, IOC (currently assumed DAY)
 * - Account: Sub-account for allocation
 * - Tags: Strategy ID, algo ID, trader ID (for audit)
 * 
 * ALTERNATIVE DESIGNS:
 * 
 * A) Multiple Orders Per Side:
 *    - std::vector<OMOrder> or std::unordered_map<OrderId, OMOrder>
 *    - Use case: Iceberg orders, multiple price levels
 *    - Trade-off: More complex, slower lookup
 * 
 * B) Callback-Based:
 *    - std::function callbacks on state transitions
 *    - Use case: Complex order dependencies
 *    - Trade-off: Overhead, harder to debug
 * 
 * C) FSM Library:
 *    - Boost.StateMachine or custom FSM
 *    - Advantage: Enforced transitions, validation
 *    - Disadvantage: Complexity, performance overhead
 * 
 * DEBUGGING TIPS:
 * - Log every state transition
 * - Assert valid transitions only
 * - Track order age (how long in each state)
 * - Monitor stuck orders (PENDING too long)
 * - Reconciliation: Compare with exchange order status
 */
